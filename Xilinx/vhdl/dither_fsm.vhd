-- VHDL Entity tripole_lib.dither.symbol
--
-- Created:
--          by - nort.Domain Users (NORT-XPS14)
--          at - 17:21:24 08/02/16
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1b (Build 2)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
USE ieee.std_logic_unsigned.all;

ENTITY dither IS
   PORT( 
      RdEn  : IN     std_ulogic;
      WData : IN     std_logic_vector (15 DOWNTO 0);
      WrEn  : IN     std_logic;
      clk   : IN     std_logic;
      rst   : IN     std_logic;
      Count : OUT    std_logic_vector (15 DOWNTO 0);
      Ready : OUT    std_logic
   );

-- Declarations

END dither ;

--
-- VHDL Architecture tripole_lib.dither.fsm
--
-- Created:
--          by - nort.Domain Users (NORT-XPS14)
--          at - 15:16:25 08/03/16
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1b (Build 2)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
 
ARCHITECTURE fsm OF dither IS

   -- Architecture Declarations
   SIGNAL Count_int : std_logic_vector(15 DOWNTO 0);  
   SIGNAL Err : std_logic_vector(4 DOWNTO 0);  
   SIGNAL Es : std_logic_vector(4 DOWNTO 0);  
   SIGNAL n0 : std_logic_vector(11 DOWNTO 0);  

   TYPE STATE_TYPE IS (
      s0,
      s1,
      s2,
      s3,
      s4,
      s5,
      s6,
      s7
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL Count_cld : std_logic_vector (15 DOWNTO 0);
   SIGNAL Ready_cld : std_logic ;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk
   )
   -----------------------------------------------------------------
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
         IF (rst = '1') THEN
            current_state <= s0;
            -- Default Reset Values
            Count_cld <= (others => '0');
            Ready_cld <= '0';
            Count_int <= (others => '0');
            Err <= (others => '0');
            Es <= (others => '0');
            n0 <= (others => '0');
         ELSE
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
               WHEN s0 => 
                  Count_int <= (others => '0');
                  n0 <= (others => '0');
                  Es <= (others =>'0');
                  Err <= conv_std_logic_vector(-5,5);
                  Ready_cld <= '1';
               WHEN s2 => 
                  n0 <= WData(15 downto 4);
                  Es(4) <= '0';
                  Es(3 downto 0) <= WData(3 downto 0);
                  Err <= conv_std_logic_vector(-5,5);
                  Count_int(11 downto 0) <= WData(15 downto 4);
                  Count_int(15 downto 12) <= (others => '0');
                  Ready_cld <= '0';
               WHEN s3 => 
                  Count_cld <= Count_int;
                  Err <= Err + Es;
                  Count_int(15 downto 12) <= (others => '0');
                  Count_int(11 downto 0) <= n0;
               WHEN s5 => 
                  Count_int <= Count_int + 1;
                  Err <= Err - 10;
                  IF (RdEn /= '1' AND
                      (Ready_cld = '1' OR WrEn /= '1')) THEN 
                     Ready_cld <= '1';
                  END IF;
               WHEN s6 => 
                  IF (RdEn /= '1' AND
                      (Ready_cld = '1' OR WrEn /= '1')) THEN 
                     Ready_cld <= '1';
                  END IF;
               WHEN s7 => 
                  Count_int <= Count_int + 1;
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      Err,
      RdEn,
      Ready_cld,
      WData,
      WrEn,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN s0 => 
            next_state <= s1;
         WHEN s1 => 
            IF (WrEn = '1') THEN 
               next_state <= s2;
            ELSIF (RdEn = '1') THEN 
               next_state <= s3;
            ELSE
               next_state <= s1;
            END IF;
         WHEN s2 => 
            IF (WData(3 downto 0) < 5) THEN 
               next_state <= s3;
            ELSE
               next_state <= s7;
            END IF;
         WHEN s3 => 
            next_state <= s4;
         WHEN s4 => 
            IF (Err(4) = '0' AND
                Err(3 downto 0) /= "0000") THEN 
               next_state <= s5;
            ELSE
               next_state <= s6;
            END IF;
         WHEN s5 => 
            IF (RdEn /= '1' AND
                (Ready_cld = '1' OR WrEn /= '1')) THEN 
               next_state <= s1;
            ELSE
               next_state <= s6;
            END IF;
         WHEN s6 => 
            IF (RdEn /= '1' AND
                (Ready_cld = '1' OR WrEn /= '1')) THEN 
               next_state <= s1;
            ELSE
               next_state <= s6;
            END IF;
         WHEN s7 => 
            next_state <= s3;
         WHEN OTHERS =>
            next_state <= s0;
      END CASE;
   END PROCESS nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   Count <= Count_cld;
   Ready <= Ready_cld;
END fsm;
